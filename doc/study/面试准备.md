-  CycliBarriar 和 CountdownLatch 有什么区别

```
 CyclicBarrier 可以重复使用已经通过的障碍，而 CountdownLatch 不能重复使用
```
- Thread为什么不能用stop方法停止线程

```
调用Thread.stop()方法是不安全的，这是因为当调用Thread.stop()方法时，会发生下面两件事：
1.即刻抛出ThreadDeath异常，在线程的run()方法内，任何一点都有可能抛出ThreadDeath Error，包括在catch或finally语句中。
2.释放该线程所持有的所有的锁。调用thread.stop()后导致了该线程所持有的所有锁的突然释放，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。
```

- 类加载过程

```
1.加载：获取定义此类的二进制字节流，生成这个类的java.lang.Class对象
2.验证：保证Class文件的字节流包含的信息符合JVM规范，不会给JVM造成危害
3.准备：准备阶段为变量分配内存并设置类变量的初始化
4.解析：解析过程是将常量池内的符号引用替换成直接引用
5.初始化：不同于准备阶段，本次初始化，是根据程序员通过程序制定的计划去初始化类的变量和其他资源。这些资源有static{}块，构造函数，父类的初始化等
6.使用：使用过程就是根据程序定义的行为执行
7.卸载：卸载由GC完成
```

- 死锁的四个必要条件

```
1.互斥条件：一个资源每次只能被一个进程使用
2.请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
3.不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
4.循环等待条件: 若干进程间形成首尾相接循环等待资源的关系
```

- SP（SharedPreferences）是进程同步的吗?有什么方法做到同步？

```
1，SharedPreferences不支持进程同步

一个进程的情况，经常采用SharePreference来做，但是SharePreference不支持多进程，它基于单个文件的，默认是没有考虑同步互斥，而且，APP对SP对象做了缓存，不好互斥同步。

MODE_MULTI_PROCESS的作用是什么?

在getSharedPreferences的时候，会强制让SP进行一次读取操作，从而保证数据是最新的，但是若频繁多进程进行读写， 若某个进程持有了一个外部sp对象, 那么不能保证数据是最新的，因为刚刚被别的进程更新了。

2，考虑用ContentProvider来实现SharedPreferences的进程同步

ContentProvider基于Binder，不存在进程间互斥问题，对于同步，也做了很好的封装，不需要开发者额外实现。

另外ContentProvider的每次操作都会重新getSP，保证了sp的一致性。

```







